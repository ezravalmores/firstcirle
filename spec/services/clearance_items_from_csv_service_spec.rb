
require 'rails_helper'

describe ClearanceItemsFromCsvService do
  let(:discounted_price_generator) { instance_double(ClearanceDiscountedPriceGenerator) }
  
  describe "#process" do
    context "total success" do
      let(:items)         { 5.times.map { FactoryGirl.create(:item) } }
      let(:file_name)     { generate_csv_file(items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }

      before do
        allow(ClearanceDiscountedPriceGenerator).to receive(:new).and_return(discounted_price_generator)
        allow(discounted_price_generator).to receive(:generate_discount).and_return(10)

        @batch_service = ClearanceItemsFromCsvService.new(uploaded_file)
        @batch_service.process!
      end

      it "creates a clearance batch" do
        expect(@batch_service.batch.new_record?).to be false
      end

      it "encounters no errors" do
        expect(@batch_service.errors.empty?).to be true 
      end

      it "holds items clearanced count" do
        expect(@batch_service.items_clearanced_count).to eq(5)
      end

      it "sets all items to 'clearanced' status" do
        clearance_status = Item::statuses['clearanced']
        items.each do |item|
          item.reload
          expect(item.status).to eq(clearance_status)
        end
      end
    end

    context "partial success" do
      let(:valid_items)       { 3.times.map { FactoryGirl.create(:item) } }
      let(:unsellable_item)   { FactoryGirl.create(:item, status: 'clearanced') }
      let(:non_existent_id)   { 987654 }
      let(:invalid_id)        { 'no thanks' }
      let(:no_id)             { nil }
      let(:float_id)          { 123.45 }
      let(:invalid_items)     {
        [
          [non_existent_id],
          [invalid_id],
          [no_id],
          [float_id],
          [unsellable_item.id],
        ]
      }
      let(:file_name)         { generate_csv_file(valid_items + invalid_items) }
      let(:uploaded_file)     { Rack::Test::UploadedFile.new(file_name) }

      before do
        allow(ClearanceDiscountedPriceGenerator).to receive(:new).and_return(discounted_price_generator)
        allow(discounted_price_generator).to receive(:generate_discount).and_return(10)

        @batch_service = ClearanceItemsFromCsvService.new(uploaded_file)
        @batch_service.process!
      end

      it "detects all errors generated by invalid items" do
        errors = @batch_service.errors.flatten
        expect(errors.count).to eq(invalid_items.count)
        expect(errors).to include("Row: #{4} - (id: #{non_existent_id}) Could not be found!")
        expect(errors).to include("Row: #{5} - (id: #{invalid_id}) Could not be found!")
        expect(errors).to include("Row: #{6} - (id: #{no_id}) is blank!")
        expect(errors).to include("Row: #{7} - (id: #{float_id}) Could not be found!")
        expect(errors).to include("Row: #{8} - (id: #{unsellable_item.id}) Item not sellable!")
      end

      it "holds items clearanced count" do
        expect(@batch_service.items_clearanced_count).to eq(3)
      end
    end

    context "All items are na valid for clearance" do
      let(:invalid_items) { [[987654], ['no thanks']] }
      let(:file_name)     { generate_csv_file(invalid_items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }

      before do
        @batch_service = ClearanceItemsFromCsvService.new(uploaded_file)
        @batch_service.process!
      end

      it "should indicate all items as having errors" do
        expect(@batch_service.errors.count).to eq(invalid_items.count)
      end
      it "should still save the batch model" do
        expect(@batch_service.batch.new_record?).to be false
      end
    end
  end
end